import xml.etree.ElementTree as ET
import argparse
import os

parser = argparse.ArgumentParser()
parser.add_argument("--input", "-i", type=str, required=True)
parser.add_argument("--output", "-o", type=str, default="sphinx_source/c_namespaces")
args = parser.parse_args()


def get_available_namespaces(input):
    """Read in an xml file generated by doxygen, and return a list of all toplevel namespaces in that file.

    Args:
        input (str): path to xml file
    """
    # the xml namespace is identified via ` kind="namespace">` in the xml file
    # example: <compound refid="namespacebasefunctions" kind="namespace"><name>basefunctions</name>

    # read in the xml file
    tree = ET.parse(input)
    root = tree.getroot()

    namespace_names = set()

    # extract the name of the namespace from the attribute `name`
    for compound in root.findall(".//compound[@kind='namespace']"):
        name_element = compound.find("name")
        if name_element is not None:
            namespace_names.add(str(name_element.text).split("::")[0])
    return namespace_names


def update_namespace_docs(available_namespaces, output):
    documented_namespaces = [filename.split(".", 0) for filename in os.listdir(output)]
    for namespace in available_namespaces:
        if namespace not in documented_namespaces:
            # now create a new file for this namespace
            """
            Metfilter
            ***********
            .. doxygennamespace:: metfilter
            :members:
            """
            print(f"Creating new docs file for namespace {namespace}")
            with open(os.path.join(output, namespace + ".rst"), "w") as f:
                f.write(f"Namespace: {namespace.capitalize()}\n")
                f.write("=" * len(f"Namespace: {namespace.capitalize()}") + "\n")
                f.write(f".. doxygennamespace:: {namespace}\n")
                f.write("   :members:\n")
                f.write("   :undoc-members:\n")
                f.write("   :private-members:\n")


if __name__ == "__main__":
    if not args.input.endswith(".xml"):
        inputfile = os.path.abspath(
            os.path.join(args.input, "docs", "xml", "index.xml")
        )
    else:
        inputfile = os.path.abspath(args.input)
    outputfolder = os.path.abspath(args.output)
    if not os.path.exists(inputfile):
        raise FileNotFoundError(f"Could not find input file {inputfile}")
    if not os.path.exists(outputfolder):
        raise FileNotFoundError(f"Could not find output directory {outputfolder}")
    print(f"Will update docs for namespaces in {outputfolder}, based on {inputfile}")
    available_namespaces = get_available_namespaces(os.path.abspath(inputfile))
    update_namespace_docs(available_namespaces, os.path.abspath(outputfolder))
